# MIT License
# Autor atual: David Assef
# Descri√ß√£o: Documento de arquitetura inicial do projeto ReciboFast
# Data: 29-08-2025

# ARQUITETURA RECIBOFAST ‚Äî Documento Inicial

Aplicativo PWA para gest√£o de alugu√©is e gera√ß√£o r√°pida de recibos, com frontend em Angular + Ionic + TailwindCSS e backend em Golang, utilizando Supabase (Postgres + Storage + Auth com Google) para persist√™ncia e autentica√ß√£o.

## Objetivos
- Agilizar a emiss√£o de recibos para alugu√©is e outras receitas.
- Controlar recebimentos (baixas) e hist√≥rico financeiro por contrato/recebedor.
- Permitir assinatura personalizada (PNG com transpar√™ncia) nos recibos, proporcional e realista.
- Operar como PWA com excelente performance e compatibilidade ampla (mobile-first).

## Checklist de requisitos (origem do pedido)
- Gerenciar receitas vindas de alugu√©is e outras fontes.
- Dar baixa em renda j√° recebida.
- Gerar recibos a qualquer momento.
- Criar e adicionar assinatura pr√≥pria no recibo.
- Aceitar PNG de assinatura sem fundo e posicionar proporcionalmente.
- Frontend: Angular + Ionic + Tailwind, UI/UX modernas, tabs estilo WhatsApp, transi√ß√µes suaves e lazy loading.
- Backend: Golang de alto desempenho.
- Banco: Supabase (DB, Storage, Auth), incluindo Google Auth.
- PWA para evitar publica√ß√£o em stores e maximizar compatibilidade.

## Vis√£o arquitetural (alto n√≠vel)
- Cliente (PWA Angular/Ionic) comunica-se com:
  - Supabase Auth para login (incl. Google) e obten√ß√£o de JWT.
  - API Backend (Go) para regras de neg√≥cio, emiss√£o de PDFs (opcional) e opera√ß√µes que exigem servidor.
  - Supabase Storage para envio/consulta de m√≠dia (assinaturas PNG, PDFs opcionais).
- Banco de Dados: Supabase Postgres com RLS (Row Level Security) e pol√≠ticas por usu√°rio.
- Offline-first: IndexedDB para cache de dados cr√≠ticos e fila de sincroniza√ß√£o; Service Worker com Workbox para cache de assets e APIs.

## Decis√µes de arquitetura
- Autentica√ß√£o: Supabase Auth no frontend; backend valida JWT via chave p√∫blica do Supabase (middleware). Evita duplicar identidade.
- Gera√ß√£o de PDF: padr√£o cliente-side (jsPDF/pdf-lib) para funcionar offline; backend oferece rota de gera√ß√£o server-side (gofpdf/pdfcpu) como fallback/alta fidelidade.
- Armazenamento de assinaturas: Supabase Storage em bucket privado com URLs assinadas tempor√°rias; metadados no Postgres.
- Padr√£o API: REST JSON, idempot√™ncia nas opera√ß√µes de baixa, versionamento via /api/v1.
- Escalabilidade: Backend stateless; usar Supabase como servi√ßo gerenciado; CDN para assets do PWA.

## Frontend (Angular + Ionic + Tailwind)
- Estrutura proposta
  - src/app/
    - core/ (guards, interceptors, config, auth)
    - pages/ (tabs e telas: dashboard, receitas, contratos, recibos, perfil)
    - components/ (UI reutiliz√°vel)
    - services/ (chamadas API, storage local, assinatura)
    - state/ (NgRx/Signals opcionais para estados globais)
    - utils/ (formatadores, valida√ß√µes)
    - pwa/ (service worker, estrat√©gia de cache)
- Navega√ß√£o
  - Tabs inferiores (estilo WhatsApp/Telegram) com Ionic Tabs.
  - Lazy loading por m√≥dulo de p√°gina, anima√ß√µes suaves.
- PWA/Offline
  - Angular Service Worker + Workbox (custom) para cache de assets e estrat√©gias de Stale-While-Revalidate.
  - IndexedDB (Dexie) para dados locais e fila de sincroniza√ß√£o (Background Sync quando dispon√≠vel).
- Gera√ß√£o de recibo
  - Template responsivo com dados preenchidos; assinatura PNG aplicada mantendo propor√ß√£o (altura/width m√°x. do campo de assinatura).
  - Exportar PDF (cliente) e opcionalmente subir ao Storage.
- Acessibilidade e UX
  - Alto contraste, tamanhos de toque adequados, feedback visual, skeletons e loaders.

## Backend (Golang)
- Estrutura (sugest√£o)
  - /cmd/api (main)
  - /internal/
    - config (env, supabase url/keys, CORS)
    - http (routers, middlewares)
    - handlers (recibos, receitas, assinaturas, contratos, auth-check)
    - services (regras: baixas, c√°lculo, gera√ß√£o PDF server)
    - repositories (acesso Postgres via pgx)
    - storage (supabase storage SDK/REST)
    - models (DTOs/entidades)
    - logging (zap/logrus)
- API
  - Autoriza√ß√£o: Bearer JWT (Supabase). Middleware valida e injeta user_id.
  - Idempot√™ncia: header Idempotency-Key para POSTs sens√≠veis (baixas, recibos).
  - Observabilidade: logs estruturados, request-id, timing.

## Banco de Dados (Supabase Postgres)
- Tabelas principais (prefixo rf_)
  - rf_profiles (id uuid PK refs auth.users, nome, documento, created_at)
  - rf_payers (id, owner_id, nome, documento, contato)
  - rf_contracts (id, owner_id, payer_id, descricao, valor_mensal, vencimento_dia, ativo)
  - rf_incomes (id, owner_id, contract_id NULL, categoria, competencia, valor, status [pendente|pago|parcial], due_date)
  - rf_payments (id, income_id, valor, pago_em, metodo, obs)
  - rf_receipts (id, owner_id, income_id, numero, emitido_em, pdf_url NULL, hash)
  - rf_signatures (id, owner_id, file_path, width_px, height_px, created_at)
  - rf_settings (owner_id PK, timezone, locale, template_padrao)
- √çndices por owner_id e busca por compet√™ncia/datas.
- RLS
  - Todas as tabelas com policy owner_id = auth.uid().
  - Buckets Storage privados com pol√≠tica por owner_id em metadados (storage.objects) ou paths por usu√°rio.

## Contratos de API (v1 ‚Äî esbo√ßo)
- Auth
  - GET /api/v1/me ‚Üí perfil do usu√°rio (derivado do JWT e rf_profiles)
- Payers/Contratos
  - GET/POST /api/v1/payers
  - GET/POST /api/v1/contracts
- Receitas e Baixas
  - GET/POST /api/v1/incomes
  - POST /api/v1/incomes/{id}/payments (baixa) ‚Äî Idempotency-Key suportado
- Recibos
  - POST /api/v1/receipts (body: income_id, options) ‚Üí retorna metadados e, se server-side, url/pdf
  - GET /api/v1/receipts/{id}
- Assinaturas
  - GET /api/v1/signatures
  - POST /api/v1/signatures (recebe URL assinada do Storage ou upload multipart para proxy seguro)

Exemplos de formatos (resumo)
- Income
  - { id, owner_id, contract_id, categoria, competencia: "2025-08", valor: 1000.00, status, due_date }
- Receipt
  - { id, income_id, numero, emitido_em, pdf_url?, hash }

## Fluxos principais
- Login (Google/Supabase) ‚Üí JWT
- Cadastro de pagador e contrato (opcional) ‚Üí cria√ß√£o de receitas recorrentes
- Lan√ßar receita avulsa ou recorrente
- Dar baixa total/parcial em receita
- Gerar recibo a partir de uma receita (paga ou no ato) com assinatura aplicada
- Upload/sele√ß√£o de assinatura PNG (fundo transparente), com preview e ajuste de escala

## Fluxo de funcionamento do app
1) Onboarding e login via Supabase (Google/Email) ‚Üí JWT salvo com expira√ß√£o.
2) Configura√ß√µes iniciais: timezone, dados do emissor, template padr√£o do recibo.
3) Cadastro de pagadores e contratos (opcional) ou lan√ßamento de receitas avulsas.
4) Lan√ßamento de receitas (valor, compet√™ncia, vencimento) ‚Äî offline permitido (IndexedDB).
5) Recebimento: registrar pagamento total/parcial (idempotente) com m√©todo e data.
6) Gera√ß√£o de recibo: selecionar receita/pagamento ‚Üí pr√©-visualizar ‚Üí aplicar assinatura ‚Üí exportar PDF.
7) Armazenamento: opcional upload do PDF ao Supabase Storage (URL assinada) e registro do hash do recibo.
8) Sincroniza√ß√£o: quando online, enviar pend√™ncias (receitas, pagamentos, assinaturas) via endpoint incremental.
9) Consulta e compartilhamento: acessar hist√≥rico, baixar/compartilhar PDFs, validar QRCode (se habilitado).

## Estrutura do recibo (design moderno em paisagem)
- Orienta√ß√£o: paisagem (A4 landscape) para distribui√ß√£o proporcional.
- Tipografia: t√≠tulo com peso m√©dio (ex.: 600), corpo leg√≠vel; fonte √∫nica embutida (ex.: DejaVuSans) para consist√™ncia.
- Layout (zonas):
  - Cabe√ßalho: logotipo (opcional), nome do emissor, CNPJ/CPF, contato, n√∫mero do recibo, data de emiss√£o.
  - Se√ß√£o do pagador: nome, documento, endere√ßo/contato (opcional), contrato vinculado.
  - Detalhes: descri√ß√£o/compet√™ncia, per√≠odo, valor bruto, descontos/juros, valor l√≠quido.
  - Assinatura: √°rea dedicada com linha base e assinatura PNG com transpar√™ncia, proporcional (altura m√°x. ~20‚Äì25% da zona; manter aspect ratio).
  - Rodap√©: QRCode (opcional) com hash/URL de verifica√ß√£o, termos legais e observa√ß√µes.
- Estilo: grid com espa√ßamentos consistentes, separadores sutis, alto contraste; uso de sombreamento leve para destaque.
- Acessibilidade: tamanhos m√≠nimos de fonte, contraste AA; evitar informa√ß√£o apenas por cor.

## Gera√ß√£o e posicionamento de assinatura
- PNG com transpar√™ncia √© carregado como Image e renderizado no canvas/PDF mantendo aspect ratio.
- Limites: largura/altura m√°ximas do campo de assinatura; escala autom√°tica e ajuste fino manual (slider).
- Densidade: usar resolu√ß√£o nativa; evitar upscale agressivo; antialiasing.
- Carimbo de data e n√∫mero de recibo; opcional QRCode com hash do recibo para verifica√ß√£o.

## PWA e Offline
- Service Worker: precache de shell, runtime cache para APIs (NetworkFirst com fallback), background sync para POSTs (baixas/recibos).
- IndexedDB para rascunhos de recibos, receitas pendentes e fila de sincroniza√ß√£o.
- Modo leitura total offline e emiss√£o de recibo local; sincroniza quando online.

## Seguran√ßa
- Nunca expor chaves secretas no cliente; usar apenas anon public key do Supabase no frontend.
- JWT verificado no backend; clock skew tolerante.
- RLS rigorosa por owner_id.
- Buckets privados com URLs assinadas curtas para download; upload via backend ou PostgREST com policy.
- Valida√ß√µes de entrada rigorosas no backend; limites de tamanho de upload; verifica√ß√£o de MIME e dimens√µes de PNG.

## Seguran√ßa refor√ßada (criptografia, SQLi e flood)
- Criptografia de campo (Field-level):
  - Dados sens√≠veis (documentos, contatos) cifrados em repouso com AES-256-GCM.
  - Envelope encryption: chave mestra (KMS/ENV) ‚Üí derive por usu√°rio com HKDF (salt = user_id) ‚Üí armazenar key_id e nonce no registro.
  - No frontend, dados locais (IndexedDB) tamb√©m cifrados (WebCrypto) com chave derivada do usu√°rio.
- SQL Injection: queries 100% parametrizadas (pgx), preferencialmente geradas com sqlc; valida√ß√£o de entrada e whitelists para ordena√ß√£o/campos.
- Flood/abuso: rate limit por IP e user_id (httprate/ulule-limiter), circuit breaker para o DB, backpressure (503) quando pool saturado.
- Cabe√ßalhos de seguran√ßa: CORS restrito, CSP, HSTS (se HTTPS), X-Content-Type-Options, Referrer-Policy.
- Auditoria: log de eventos sens√≠veis (upload assinatura, gera√ß√£o e download de PDF) com request-id e user_id.

## Desempenho
- Go backend com pooling de conex√µes (pgxpool), timeouts e compress√£o HTTP.
- Angular com lazy loading, route-level code splitting e Tailwind JIT.
- Cache de lista de receitas/contratos; pagina√ß√£o e filtros no servidor.
- JSON: considerar goccy/go-json ou jsoniter para reduzir aloca√ß√µes (validar compatibilidade antes).
- HTTP server: keep-alive, HTTP/2, gzip/br; definir Read/Write/Idle timeouts, e limitar body size.

## Telemetria e Logs
- Logs estruturados no backend (request-id, user_id, lat√™ncia, erros).
- M√©tricas b√°sicas (Prometheus/OpenTelemetry) ‚Äî contadores de recibos emitidos, lat√™ncia de gera√ß√£o.
- Amostragem de logs em produ√ß√£o para reduzir I/O em servidores freemium.

## Estrutura de pastas sugerida
- Frontend
  - src/app/{core,components,pages,services,state,utils,pwa}
- Backend ‚úÖ IMPLEMENTADO
  - cmd/main.go ‚úÖ
  - internal/
    - context/    ‚Üí Gerenciamento de contexto de usu√°rio ‚úÖ
    - handlers/   ‚Üí Controllers (sync endpoint implementado) ‚úÖ
    - httpserver/ ‚Üí Configura√ß√£o do servidor HTTP ‚úÖ
    - middleware/ ‚Üí Autentica√ß√£o Supabase (JWKS) ‚úÖ
    - models/     ‚Üí Structs e valida√ß√µes ‚úÖ
    - services/   ‚Üí L√≥gica de neg√≥cio ‚úÖ
    - config/     ‚Üí Configura√ß√µes (env, DB, Supabase) ‚úÖ
    - logging/    ‚Üí Logs estruturados ‚úÖ
    - repositories/ ‚Üí Acesso a dados (Supabase) ‚úÖ
- Infra
  - supabase/ (migrations, policies)
  - docs/ (diagramas, templates)

**Funcionalidades Backend Implementadas:**
- ‚úÖ Servidor HTTP com Chi router
- ‚úÖ Middleware de autentica√ß√£o JWT Supabase
- ‚úÖ Valida√ß√£o JWKS autom√°tica
- ‚úÖ Contexto de usu√°rio thread-safe
- ‚úÖ Logs estruturados com zap
- ‚úÖ Endpoint /api/v1/sync/changes
- ‚úÖ Modo debug para desenvolvimento
- ‚úÖ Conex√£o com PostgreSQL Supabase

## Vari√°veis de ambiente (exemplos)
- FRONTEND
  - NG_APP_SUPABASE_URL
  - NG_APP_SUPABASE_ANON_KEY
  - NG_APP_API_BASE_URL
- BACKEND
  - API_PORT, CORS_ORIGINS
  - SUPABASE_URL, SUPABASE_JWT_PUBLIC_KEY
  - DB_URL (fornecido pelo Supabase ‚Äî preferir string de conex√£o Pooled)
  - STORAGE_BUCKET_SIGNATURES, STORAGE_BUCKET_RECEIPTS

## Qualidade e boas pr√°ticas
- Nomes descritivos; modulariza√ß√£o; evitar duplica√ß√£o.
- Linters: ESLint+Prettier (front), golangci-lint (back).
- Tipagem: TypeScript forte no front; tipos expl√≠citos nos DTOs Go.
- Testes: Jest/Testing Library no front; Go test no back; cen√°rios de gera√ß√£o de PDF e pol√≠ticas RLS.
- Build Go: CGO_ENABLED=0, -ldflags "-s -w"; opcional UPX (avaliar suporte da plataforma de deploy).

## Otimiza√ß√µes para servidores freemium (foco em Golang)
- Pool de conex√µes: pgxpool com limites baixos (ex.: max_conns 5‚Äì10), idle timeout e healthcheck; usar conex√£o pooled do Supabase.
- Consultas: evitar N+1; preferir joins controlados e proje√ß√µes enxutas (SELECT colunas necess√°rias). √çndices compostos por (owner_id, due_date) e (owner_id, competencia).
- Caching leve: in-memory com TTL curto (ristretto) para listas frequentes (p.ex. √∫ltimos recibos). Budget de mem√≥ria pequeno (ex.: 16‚Äì32MB).
- Serializa√ß√£o: substituir encoding/json por goccy/go-json ou jsoniter onde for hot-path; medir antes/depois.
- Rate limit e backpressure: token bucket por IP e por user_id (ulule/limiter). Retornar 429 com Retry-After. Circuit breaker simples para o DB (gobreaker).
- Tarefas custosas: gera√ß√£o de PDF preferencialmente no cliente; fallback no servidor com gofpdf minimalista, reuso de buffers (sync.Pool) e fontes embutidas; limitar tamanho de imagens e p√°ginas.
- Uploads de imagem: validar MIME, limitar dimens√µes (ex.: 1200x400 m√°x para assinaturas) e tamanho (ex.: 200KB). Opcional reprocessar PNG para reduzir peso preservando alpha.
- Respostas HTTP: ETag/If-None-Match em GETs; gzip/br; pagina√ß√£o padr√£o (limit 20) e hard limit (m√°x 100).
- Inicializa√ß√£o r√°pida: evitar reflex√£o pesada, inicializar clientes de forma lazy; pr√©-aquecer caches sob demanda.
- Logs: n√≠vel WARN em produ√ß√£o; sample em 1% para INFO/DEBUG.
- Confiabilidade: idempot√™ncia via hash √∫nico (unique index) para pagamentos/recibos; sequ√™ncia global para n√∫mero de recibos.
- Timeouts: contexto com deadlines curtos (p.ex. 300‚Äì800ms para queries usuais); retries exponenciais limitados.

## Melhorias de modelagem e consultas
- Sequ√™ncia global de recibos + prefixo por owner_id para numera√ß√£o est√°vel e baixa conten√ß√£o.
- Vistas materializadas: resumos mensais por owner (receitas, pagos, pendentes) com refresh programado.
- Colunas derivadas: total_pago em rf_incomes mantido por trigger para evitar somas repetidas.

## Frontend ‚Äî performance e UX em PWA
- Angular build com budgets e "optimization": true; remover polyfills n√£o usados.
- Tailwind com purge agressivo; evitar libs pesadas de UI; preferir componentes Ionic nativos.
- Imagens e fontes: SVG/WOFF2; √≠cones por sprite.
- Estrat√©gias de cache: SWR para listas; NetworkFirst para dados cr√≠ticos; fallback offline amig√°vel.
- Progressive enhancement: app funciona sem anima√ß√µes pesadas em devices fracos.

## Opera√ß√£o em freemium
- CDN para est√°ticos do PWA; HTTP caching forte (1y, immutable) nos assets versionados.
- Healthchecks leves; readiness/liveness endpoints baratos.
- Observabilidade minimalista: m√©tricas essenciais (contadores, erros, p50/p95).
- Prote√ß√£o contra abuso: CAPTCHA leve em cria√ß√µes massivas; limites por usu√°rio.

## API de sincroniza√ß√£o incremental (esqueleto em Go)
Exemplo de handler usando chi (ilustrativo):

```go
// ...imports (net/http, time, encoding/json, ...)

// GET /api/v1/sync/changes?since=RFC3339&limit=100&cursor=...
func (h *SyncHandler) GetChanges(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    userID := h.Auth.FromContext(ctx) // obtido via middleware que valida JWT Supabase

    sinceStr := r.URL.Query().Get("since")
    var since time.Time
    var err error
    if sinceStr == "" {
        since = time.Now().Add(-24 * time.Hour)
    } else {
        since, err = time.Parse(time.RFC3339, sinceStr)
        if err != nil { http.Error(w, "invalid since", http.StatusBadRequest); return }
    }
    limit := parseLimit(r.URL.Query().Get("limit"), 100)
    cursor := r.URL.Query().Get("cursor")
    fields := r.URL.Query().Get("fields") // opcional para proje√ß√µes

    res, nextCursor, etag, err := h.Svc.FetchChanges(ctx, userID, since, limit, cursor, fields)
    if err != nil { h.Err(w, err); return }

    if match := r.Header.Get("If-None-Match"); match != "" && match == etag {
        w.WriteHeader(http.StatusNotModified); return
    }
    w.Header().Set("ETag", etag)
    w.Header().Set("Content-Type", "application/json")

    enc := h.JSONEncoder // ex.: goccy/go-json
    _ = enc.NewEncoder(w).Encode(struct {
        Changes    interface{} `json:"changes"`
        NextCursor string      `json:"next_cursor,omitempty"`
    }{Changes: res, NextCursor: nextCursor})
}
```

- Servi√ßo `FetchChanges` deve retornar somente registros com `updated_at > since` incluindo soft-deletes (`deleted_at`).
- Suportar gzip/br e pagina√ß√£o por cursor; campos seletivos via `fields`.

## APIs de sincroniza√ß√£o eficiente (redu√ß√£o de payload e CPU)
- GET /api/v1/sync/changes?since=timestamp ‚Äî retorna somente altera√ß√µes ap√≥s ‚Äòsince‚Äô por entidade.
- Usar timestamps monot√¥nicos (updated_at) e soft-deletes (deleted_at) para reconciliar no cliente.
- Suporte a compacta√ß√£o gzip/br e ETag para respostas de sync.

## Ajustes de contratos e limites
- Todas as listas devem aceitar: fields, limit, cursor/next_token e ETag condicional.
- Uploads: limitar tamanho (ex.: 200KB) e dimens√µes; rejeitar reprocessamento caro no servidor.
- Tarefas pesadas no servidor (PDF): timeout curto (ex.: 2‚Äì5s) e retorno 202 com polling opcional.

## Docker e Deploy
- Backend (Go) multi-stage:
  - Stage builder: golang:1.22-alpine com GOFLAGS="-ldflags='-s -w'" e CGO_ENABLED=0.
  - Stage final: scratch/distroless, copiar bin√°rio e certs; expor API_PORT.
- Frontend (Angular/Ionic):
  - Build node:20-alpine ‚Üí gerar dist; servir com nginx:alpine com headers de cache fortes.
- docker-compose.yml (dev):
  - services: backend, frontend (nginx), caddy/nginx reverso (TLS local opcional).
  - Vari√°veis: SUPABASE_URL/KEY, DB_URL, CORS_ORIGINS, API_PORT, NG_APP_*.
- Observa√ß√£o: Supabase gerenciado (SaaS); n√£o subir Postgres local no compose.

## Roadmap inicial
1) ‚úÖ Setup Supabase (tabelas, RLS, buckets, triggers e √≠ndices)
2) ‚úÖ Backend Skeleton (Go) - Implementado
3) üîÑ Frontend Skeleton (PWA com tabs, auth, rotas lazy, SW) - Em Andamento
4) Fluxo de receitas/baixas (com idempot√™ncia e pagina√ß√£o)
5) Upload e gest√£o de assinaturas (valida√ß√£o e limites)
6) Gera√ß√£o de recibo (client) + fallback server otimizado
7) Sincroniza√ß√£o incremental e background sync
8) Telemetria, rate limiting e polimento de UX

## Status Atual do Projeto ‚úÖ
- **Fase atual**: Fase 3 - Frontend Skeleton (Em Andamento)
- **Fases conclu√≠das**: 
  - ‚úÖ Fase 0: Prepara√ß√£o do ambiente
  - ‚úÖ Fase 2: Backend Skeleton (Go)
- **Pr√≥ximos passos**: 
  - Criar projeto Angular/Ionic com estrutura de tabs
  - Implementar autentica√ß√£o Supabase no frontend
  - Configurar PWA e Service Worker
  - Setup IndexedDB com Dexie

## Sugest√µes de melhorias e diferenciais
- Templates de recibo personaliz√°veis e tema escuro/claro autom√°tico.
- QRCode no recibo com verifica√ß√£o p√∫blica do hash/validade.
- Recorr√™ncia autom√°tica de receitas com calend√°rio e lembretes push (Web Push).
- Exporta√ß√µes (CSV/Excel) e integra√ß√£o com contabilidade.
- Modo ‚ÄúOperador‚Äù multiusu√°rio com pap√©is/ACL por time.
- Assistente de onboarding orientado por checklist.
- Suporte completo a PWA: instala√ß√£o em iOS/Android/Desktop, √≠cones adaptativos, navega√ß√£o full-screen.
- Modo "Lite" que reduz anima√ß√µes e desativa pr√©-carregamentos em dispositivos/planos limitados.
- Pr√©-visualiza√ß√£o de recibo com render incremental para dispositivos lentos.

## Novas melhorias identificadas (an√°lise adicional)
- Denormaliza√ß√£o controlada para listas (ex.: armazenar nome do pagador no rf_incomes) reduzindo joins frequentes.
- E2E de performance: testes k6 com cen√°rios leves, budget de lat√™ncia e erro; regress√µes bloqueiam deploy.
- ETags + Cache-Control em todas as listas e detalhes; valida√ß√£o condicional para salvar largura de banda.
- Pol√≠tica de reten√ß√£o de logs e dados tempor√°rios para evitar encher disco/quotas.
- Hard caps por usu√°rio (itens por m√™s, PDFs armazenados) com mensagens claras e upsell futuro.
- Mecanismo de limpeza de rascunhos/arquivos √≥rf√£os no Storage (tarefa agendada fora do hor√°rio de pico).

‚Äî Fim ‚Äî
